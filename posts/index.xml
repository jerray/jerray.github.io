<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Seven Lemons</title>
    <link>https://jerray.github.io/posts/</link>
    <description>Recent content in Posts on Seven Lemons</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 10 Jan 2016 22:28:06 +0800</lastBuildDate>
    
	<atom:link href="https://jerray.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>日志要认真写</title>
      <link>https://jerray.github.io/posts/20160110-logging/</link>
      <pubDate>Sun, 10 Jan 2016 22:28:06 +0800</pubDate>
      
      <guid>https://jerray.github.io/posts/20160110-logging/</guid>
      <description>曾经，我是不怎么关心程序里的日志的。每次写程序都是写完逻辑，顺带着在一些关键部位加一些日志记录。或者是在调试的过程中插入一些日志。在测试环境这么做完全没问题。因为整个环境只有我一个人在用，每次执行程序，只有那几条日志被打印出来而已。肉眼一扫就知道有没有问题了。工作中发现，很多人其实也是这样，随手写点日志，甚至根本不写日志。
糟糕的日志 直到有一天我需要检查一个问题，有反馈说某个用户收不到我们系统发出的消息。怎么回事呢？系统在线上运行了，也不能为了这一个个例停掉整个系统来调试吧？投递消息这里应该记录了日志，于是打开日志文件检查，看到了如下让人目瞪口呆的内容：
[2015-12-01 14:54:33][INFO] send message ok [2015-12-01 14:54:33][INFO] send message fail [2015-12-01 14:54:33][INFO] send message ok [2015-12-01 14:54:34][INFO] send message ok [2015-12-01 14:54:34][INFO] send message fail [2015-12-01 14:54:35][INFO] send message ok  这谁写的日志给我站出来！你语文是体育老师教的吗？
老师从小就教导我们，叙述事情要讲清楚时间，地点，人物，事件。这一条日志你只写了个事件，时间都是框架帮你写好的，然后事件你还没讲清楚。有十个模块在发消息，我怎么直到这些日志是哪个模块写的？就算只有一个模块在记录这些日志，怎么能知道是发给谁的消息成功或者失败了？发送失败了，那么原因是什么？
详细的日志 有些同学没有意识到日志的作用。日志是用来记录事情的。它并不是给你调试用的工具，调试程序有专门的调试工具可以用。既然是描述事情的就需要具备上面至少四点：时间，地点，人物，事件。那么按照这个思路再来考虑一下日志应该怎么写。
时间一般的日志系统会自动加上。地点就可以写上哪个模块。人物可以写触发这个事件的主体。事件当然就描述发生了什么，详细程度可根据实际需要适当调整。修改后的日志写出来大概是这样：
[2015-12-01 14:54:34][INFO] SMS_Sender [verify] send message to [186XXXXZZZZ] ok [2015-12-01 14:54:34][ERROR] SMS_Sender [verify] send message to [110] fail: invalid phone number  差不多就是这个意思。这两行日志比之前那种好得多，至少一眼看去直到是哪个模块在调用什么类型的过程时出了什么样的问题。正确的事件并不需要太多细节，而发生错误的事件我需要知道发生了什么样的错误。大部分情况下，这种详细程度的日志就足够应付生产环境的大部分问题了。
可追踪的日志 至于日志需要描述得多细致，还是需要根据实际情况去斟酌。比如我有一个支付系统，虽然我的数据库里也有支付记录，但是我还是需要日志来跟踪一些操作。那么，可能我在整个支付流程的日志中，每条都要加入一个唯一的ID。这样就可以根据这个ID来追踪程序的运行流程。
[2015-12-01 14:54:40][INFO] Pay [9cb3][generate] create order for user 1, id:36 [2015-12-01 14:54:40][INFO] Pay [9cb3][delay] checking status job dispatched for order id:36 [2015-12-01 14:54:40][INFO] SMS_Sender [9cb3][verify] send message to [186XXXXZZZZ] ok  其他用途 有人会问，记这些东西除了出了问题查起来方便，还能有什么用？其实出了问题查找起来方便是日志主要作用。除了这个还能用来做告警，还能用来做统计分析。</description>
    </item>
    
    <item>
      <title>为什么要自己写个HTML数字键盘</title>
      <link>https://jerray.github.io/posts/20151230-keyboard/</link>
      <pubDate>Wed, 30 Dec 2015 22:27:48 +0800</pubDate>
      
      <guid>https://jerray.github.io/posts/20151230-keyboard/</guid>
      <description>我们有个面向移动端的HTML页面，使用的时候需要在一个输入框里输入些数字。一开始的时候为了快速实现功能，直接放了个input框在那里。
结果就是使用的时候需要先点击输入框，弹出键盘以后要切换到数字键盘，接着才能输入数字。但是，你永远无法预知用户如何使用你的产品，很快我们就发现有乱七八糟的字符被提交上来了。可是我们要的只是数字而已。于是，给input框绑了个事件，每次用户输入之后检查用户输入的内容，如果内容不是数字，那就不写进input框里。
如果事情就这样结束了可能还要花好久我们才能想到自己写个数字键盘。由于用户的移动设备的差异，input框检查需要兼容很多情况，各种浏览器，各种输入法。虽然我们在各种测试机上测试都没问题，但是还是有反馈说能输入框里能输入中文。甚至把input的type属性改成了number也没用。
想了想这么下去也不是办法，还不如自己写个HTML版本的键盘。这样不仅能够掌控用户操作，使体验趋于一致，还能极大减少兼容性问题。
功能要点  点击数字键的时候能够正确追加数字 只能输入一个小数点 点击删除键的时候能正确去掉尾部的字符  花边儿功能  如果内容为0，输入其他数字时变为其他数字 如果还未输入内容，点击两次0的时候只追加一个0 如果还未输入内容，点击小数点的时候在前面补0 默认只能输入两位小数 提供初始化完成的回调 提供按键按下和弹起的回调 提供键盘滑入滑出效果和调用方法  实现 从上面的功能来看，其实只是一个简单的状态机而已，并没有任何复杂的功能，实现难度简直一星。无非是写点HTML标签当作按键，每个按键上绑定点击事件，然后根据点击的按键把输入值传给状态机就可以了。
这里只有一个问题就是监听什么事件。最先想到的还是监听click事件，在PC浏览器上测试完全没问题。但是手机的浏览器对click的处理有个几百毫秒的延迟，导致用起来一点也不流畅。于是改为监听touchstart，这样就会随着点击立刻触发事件了。调试的时候可以使用Chrome来调试，打开开发者工具，然后点击上面那个手机状的小图标开启手机模式。
代码 一开始没想过独立成一个模块的。我们在前端页面里插入了Bugsnag错误上报，发现任何未catch的错误都会上报到Bugsnag，主要用来发现客户端异常。但是后来发现很多来自127.0.0.1和/Users/some-user-name/path/xxx.html发来的异常。想了想这个页面也没啥值得撸的，能扒的也就只有键盘了。恰巧也正要模块化给其他的页面用，也没什么技术难度，于是丢到了GitHub上。
仓库地址：JK-Keyboard
NPM: JK-Keyboard</description>
    </item>
    
    <item>
      <title>说说测试的事</title>
      <link>https://jerray.github.io/posts/20151219-testing/</link>
      <pubDate>Sat, 19 Dec 2015 22:27:29 +0800</pubDate>
      
      <guid>https://jerray.github.io/posts/20151219-testing/</guid>
      <description>我是一个不专业的程序员。每次接到新的题目，在纸上画画逻辑，想想手头现有的资源，琢磨琢磨程序结构，然后就直接把代码写出来了。写完以后一般是在命令行或者网页上走一遍。发现哪里不对再到代码里打点，插日志，然后再走一遍。就这样一遍一遍重复，最后自己认为没问题了，“走起，上线！”
时间没过多久，接到新的需求说要在上次的功能上加点儿东西。Easy，加！嗯，这里这个流程可以封装一下，于是封装了一个函数。接着开始实现新的需求。写完了以后在命令行或者网页上走一遍新的需求，发现没问题，“走起，上线！”
过了不一会儿接到消息说，原来运行正常的某个功能不好使了。你们这帮人，错就说错在哪，不好使是什么意思？打开日志一看，还真不好使了。于是又补了点儿日志，查查到底怎么个情况。噢，原来上次封装的那个函数那里出了点问题，改吧。改完再走一遍原来的流程，发现没啥问题，“走起，上线！”
又过了一会儿，说刚刚做的新需求又出问题了……你这不是跟我闹呢么！
人肉测试 前面写得有点夸张，真是这样的话早被开除800回了。这里问题也很明显：每次实现功能之后，没有进行系统完整的测试就匆忙（哪来的自信）上线了。我需要些测试来保证程序的质量。
于是我想了个办法，把需要测试的功能点列个表，每次做完的时候要逐个检查每项功能是否正确。怎么检查？当然是网页上的流程就去点网页，命令行的流程就去执行命令行，涉及到数据的再去检查数据库记录咯！一开始，这个方法是有效的，直到每次上线前我要检查500个功能点……
你不说你是程序员么 检查一个功能点要1分钟的话，检查500个功能点就要500分钟，一天都过去了还上不了线只能加班。如果每天都有新需求过来，每天都要上线的话……太可怕，不敢想。我们这儿没有专职的测试人员，只能写程序的程序员自己来测试功能，等等……
对啊，我不是程序员么？既然我能写程序，为啥我就不能写个程序去测试我的程序呢？这样就不用每次上线之前都手动检查之前的功能点了啊！说干就干，不能整天把时间浪费在点网页上（甚至有些移动端的网页还要掏出手机来各种操作，简直了）！
说干就干的单元测试 我想，至少要保证程序的每个小单元正确，这样把它们拼装起来才能正确吧！于是，找个了文件，先对里面的这个类写个测试程序好了。建个文件，引用下这个类，创建个实例。然后针对要测试的第一个方法写个函数，调用这个函数，判断下输出是否符合预期。如果不符合，在命令行里打出一行错误信息。
按照上面的流程写完整个类的测试代码，“走起！”如我所愿（嘴角露出了自满的微笑），并没有报错。但是，其实我并没有满足。因为在测试程序里，每个要测试的方法我只调用了一次，还有一些边界条件需要检查。并且，有些函数里有逻辑分支，我要想想怎么把这些分支都测到。
经过一番折腾，终于写完了一个小程序去测试一个类啦！并且我试着在类上加一些对原有逻辑有破坏性的代码，这时再跑一遍测试程序，果然报错了，赞！
于是这一天什么工作都没做，只是写了个测试脚本。要苦逼加班了！
写什么测试啊浪费时间 因为这几天一直在琢磨测试的事，被吐槽工作进度太慢。你瞅瞅那谁家小谁，100个功能都做完了你还在这磨洋工！我说我在写测试啊，然后又被训了：“你这明显增加代码量啊，平白无故给自己增加负担知道不知道？给你的工资可不包含这部分代码，这是你自己要写的。浪费时间……”
但是我不死心啊，哼，你懂什么，除了催就知道催。我这可是工作自动化。
原来还有测试框架 见识短浅了，自己写了一套东西以后才发现原来还有一堆叫做测试框架的玩意儿。研究了一下找个用的人多的直接拿来用好了。这东西用着确实爽，哪儿还用自己写报错信息，哪还用自己写些if else判断函数输出，早有人帮你写好了。什么assert，一会儿should一会儿又expect的，整不明白反正就用吧！
从测试中受益 渐渐地发现，别人在网页检查数据的时候，我在写测试代码检查网页的数据；别人在数据库里检查数据的时候，我在写测试代码检查数据库的数据；别人在发网络请求检查返回数据处理的时候，我伪造了网络请求返回了期望的数据；别人在网页上走流程的时候，我一个命令自动生成了一堆数据在几秒钟内走了一遍完成的流程……这回咱说上线就上线，就是这么自信！
哼哼哼，那谁家小谁做100个功能，我也能做100个功能，我还能“尽量”保证这100个功能的稳定。
慢慢地发现，好像工作也并没有那么复杂了。因为大部分烦人的验证过程都交给了测试程序去做。并且后来我做了个脚本，每当项目的一个文件有变化的时候，就自动执行相应的测试。如果测试没通过，就发个通知给我。后来索性就先写测试，然后再写程序代码，写着写着测试通过了，我就知道这段逻辑大致没啥问题啦！
因为空下来很多时间，这段时间我就到处去看其他乱七八糟的项目，偶尔还玩玩游戏。后来，空下来的这段时间，我就只用来玩游戏。后来就被开除了。😂</description>
    </item>
    
  </channel>
</rss>